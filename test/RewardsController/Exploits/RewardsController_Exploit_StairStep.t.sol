// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {RewardsController_Test_Base} from "../RewardsController_Test_Base.sol";
import {IRewardsController} from "../../../src/interfaces/IRewardsController.sol";
import {console} from "forge-std/console.sol";

contract RewardsController_Exploit_StairStep_Test is RewardsController_Test_Base {
    IRewardsController.BalanceUpdateData[] internal noSimUpdatesForClaim; // Empty array

    function setUp() public override {
        super.setUp();
        // USER_A already has DAI (rewardToken) from base setUp.
        // mockERC721 is already added as a collection (NFT_COLLECTION_1).
        // NFT_COLLECTION_1 uses RewardBasis.BORROW
    }

    function test_T1_Exploit_BuyClaimSellClaim() public {
        address collection = address(mockERC721); // NFT_COLLECTION_1

        // 1. User A "buys" NFT / starts borrowing associated with the NFT
        // Mint NFT to USER_A
        vm.startPrank(OWNER);
        mockERC721.mintSpecific(USER_A, 1); // NFT ID 1 for USER_A
        vm.stopPrank();

        // Process balance update: User A now has 1 NFT for the collection and a borrow balance of 1000
        // This makes USER_A eligible for rewards.
        _processSingleUserUpdate(USER_A, collection, block.number, int256(1), int256(1000 * PRECISION));

        // 2. Advance time to accrue some rewards
        vm.warp(block.timestamp + 1 days); // Advance time by 1 day
        vm.roll(block.number + 100); // Advance 100 blocks

        // 3. Generate some yield in the system so there's something to claim
        // _generateYieldInLendingManager will ensure mockCToken has funds and set exchange rates.
        // We then need to transfer this yield to RewardsController.
        uint256 yieldToGenerate = 100 * PRECISION;
        _generateYieldInLendingManager(yieldToGenerate); // Generates yield in LendingManager

        // LendingManager needs to have DAI to transfer. The _generateYieldInLendingManager
        // deals DAI to mockCToken and adjusts exchange rates.
        // To make it simpler for transferYield, let's also ensure LendingManager has some DAI.
        // The base setup already deals DAI to LendingManager (line 135 of base).
        // Let's ensure enough is available via transferYield.
        // The `transferYield` function in RewardsController should pull from LendingManager.
        vm.prank(address(lendingManager)); // Or any authorized address if restricted
        // rewardsController.transferYield(); // This function does not exist; yield is pulled by claim functions.

        uint256 rewardsBalanceBeforeTest = rewardToken.balanceOf(USER_A);

        // --- Start of "close succession" sequence ---

        // 4. User A claims rewards (First Claim)
        vm.startPrank(USER_A);
        rewardsController.claimRewardsForCollection(collection, noSimUpdatesForClaim);
        vm.stopPrank();

        uint256 rewardsAfterFirstClaim = rewardToken.balanceOf(USER_A) - rewardsBalanceBeforeTest;
        assertTrue(rewardsAfterFirstClaim > 0, "First claim should yield some rewards");

        // 5. User A "sells" NFT / stops borrowing (balance becomes 0 for this collection)
        // Transfer NFT away from USER_A
        vm.startPrank(USER_A); // USER_A transfers their own NFT
        mockERC721.transferFrom(USER_A, USER_B, 1); // NFT ID 1 transferred to USER_B
        vm.stopPrank();

        // Process balance update: User A now has 0 NFTs and borrow balance of 0 for this collection.
        // This update is for the current block.number (or the block number of the transfer).
        // The exploit fix should ensure this update is considered for subsequent claims.
        _processSingleUserUpdate(USER_A, collection, block.number, int256(-1), int256(-1000) * int256(PRECISION));

        // 6. User A attempts to claim rewards again for the same collection (Second Claim)
        // This claim should be based on the new state (0 balance or very short duration with balance).
        // Expected: negligible rewards from this second claim.
        vm.startPrank(USER_A);
        rewardsController.claimRewardsForCollection(collection, noSimUpdatesForClaim);
        vm.stopPrank();
        // --- End of sequence ---

        uint256 rewardsBalanceAfterTest = rewardToken.balanceOf(USER_A);
        uint256 totalRewardsClaimedInTestSequence = rewardsBalanceAfterTest - rewardsBalanceBeforeTest;

        // The rewards from the second claim should be negligible (ideally 0, allowing for 1 wei dust).
        uint256 rewardsFromSecondClaimInSequence = totalRewardsClaimedInTestSequence - rewardsAfterFirstClaim;

        assertLe(
            rewardsFromSecondClaimInSequence, 1, "Second claim in exploit scenario should yield <= 1 wei of rewards"
        );
    }

    function test_SegmentedRewards_BuyClaimSellClaim_OneBlock_TheoreticalCheck() public {
        address collection = NFT_COLLECTION_1; // from RewardsController_Test_Base
        address user = USER_A;
        uint256 initialNftCount = 1;
        uint256 initialLpBalance = 1000 * PRECISION;

        // Ensure yield is available in the system
        _generateYieldInLendingManager(20000 * PRECISION);
        uint256 initialUserRewardTokenBalance = rewardToken.balanceOf(user);

        // 1. "Buy" Action: User acquires NFT and LP balance responsibility
        vm.startPrank(OWNER); // Assuming OWNER can mint or assign NFTs
        mockERC721.mintSpecific(user, 1); // Mint NFT ID 1 to user
        vm.stopPrank();

        uint256 buyBlock = block.number + 1;
        vm.roll(buyBlock); // Ensure a distinct block for the update if necessary for clarity
        _processSingleUserUpdate(user, collection, buyBlock, int256(initialNftCount), int256(initialLpBalance));

        // Capture the starting reward index for the period user holds the asset
        uint256 startIndexForTheoretical = rewardsController.getUserRewardState(user, collection).lastRewardIndex;

        // 2. Advance Time slightly & Capture End Index for Theoretical Calculation
        // This simulates the period during which rewards accrue before any claims or sales.
        vm.warp(block.timestamp + 60); // Advance time by 60 seconds
        vm.roll(block.number + 10); // Advance 10 blocks
        rewardsController.updateGlobalIndex(); // Update global index based on new time/block
        uint256 endIndexForTheoretical = rewardsController.globalRewardIndex();

        assertTrue(
            endIndexForTheoretical > startIndexForTheoretical, "End index for theoretical calc must be > start index"
        );

        // 3. First Claim
        // User claims rewards accrued so far.
        // All actions from here (claim, sell, claim) are intended to be "in one block" conceptually,
        // meaning no significant time passage that would independently accrue more rewards between these steps.
        // The vm.roll calls are minimal to ensure distinct block numbers for updates if the system requires it.
        vm.roll(block.number + 1);
        vm.startPrank(user);
        rewardsController.claimRewardsForCollection(collection, noSimUpdatesForClaim);
        vm.stopPrank();
        // uint256 rewardsAfterFirstClaim = rewardToken.balanceOf(user) - initialUserRewardTokenBalance;

        // 4. "Sell" Action: User relinquishes NFT and LP balance responsibility
        vm.roll(block.number + 1);
        uint256 sellBlock = block.number;
        vm.startPrank(user); // User initiates the transfer of their NFT
        mockERC721.transferFrom(user, USER_B, 1); // Transfer NFT ID 1 to USER_B
        vm.stopPrank();
        _processSingleUserUpdate(user, collection, sellBlock, -int256(initialNftCount), -int256(initialLpBalance));

        // 5. Second Claim
        // User claims any remaining rewards. Due to the preceding "sell", this should primarily account for
        // rewards accrued between the first claim and the sell, based on the snapshot logic.
        vm.roll(block.number + 1);
        vm.startPrank(user);
        rewardsController.claimRewardsForCollection(collection, noSimUpdatesForClaim);
        vm.stopPrank();
        uint256 totalRewardsClaimed = rewardToken.balanceOf(user) - initialUserRewardTokenBalance;

        // 6. Calculate Theoretical Reward for the entire holding period
        // This uses the _calculateRewardsManually helper from the base test contract.
        uint256 theoreticalTotalReward = _calculateRewardsManually(
            user, collection, initialNftCount, initialLpBalance, startIndexForTheoretical, endIndexForTheoretical
        );

        console.log("Total Claimed: %s", totalRewardsClaimed);
        console.log("Theoretical Total: %s", theoreticalTotalReward);

        // 7. Assertion: Total claimed should be very close to the theoretical calculation.
        assertApproxEqAbs(
            totalRewardsClaimed,
            theoreticalTotalReward,
            1, // Allow 1 wei difference for potential dust
            "Total claimed reward vs. theoretical reward mismatch"
        );
    }
}
